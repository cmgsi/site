{"ast":null,"code":"import XLSX from \"xlsx\";\nexport const Worksheet2FoamTree =\n/** @constructor */\nfunction (worksheet) {\n  const log = [];\n  const dataObject = {\n    groups: []\n  };\n  const propertyHeadings = [];\n\n  this.getLog = () => log;\n\n  this.getDataObject = () => dataObject;\n\n  this.getPropertyNames = () => propertyHeadings;\n\n  const get = (r, c) => worksheet[XLSX.utils.encode_cell({\n    c: c,\n    r: r\n  })];\n\n  const getV = (r, c) => {\n    const e = get(r, c);\n    return e && e.v;\n  }; // Ensure that the worksheet is not empty\n\n\n  const rangeRaw = worksheet[\"!ref\"];\n\n  if (!rangeRaw) {\n    log.push({\n      code: \"E001\"\n    });\n    return;\n  } // Check if there is any data. The first row is a heading.\n\n\n  const range = XLSX.utils.decode_range(rangeRaw);\n\n  if (range.e.r <= 0) {\n    log.push({\n      code: \"W001\"\n    });\n    dataObject.groups = [];\n    return;\n  } // Look for level headings, we require a specific level heading format defined below.\n\n\n  const LEVEL_HEADING_REGEX = /level\\s+\\d+/i;\n  let maxLevels = 0;\n\n  while (maxLevels <= range.e.c && LEVEL_HEADING_REGEX.test(getV(0, maxLevels))) {\n    maxLevels++;\n  } // No level headings found\n\n\n  if (maxLevels === 0) {\n    log.push({\n      code: \"E002\"\n    });\n    return;\n  } // Headings beyond the hierarchy definitions. These will be the custom group properties.\n\n\n  let i = maxLevels;\n\n  while (i <= range.e.c) {\n    propertyHeadings.push(getV(0, i));\n    i++;\n  } // Build the data object.\n\n\n  const root = {\n    groups: new Map()\n  };\n\n  const getOrCreateGroup = (root, v) => {\n    let group = root.groups.get(v);\n\n    if (!group) {\n      group = {\n        label: v,\n        groups: new Map()\n      };\n      root.groups.set(v, group);\n    }\n\n    return group;\n  };\n\n  for (let r = 1; r <= range.e.r; r++) {\n    // Hierarchy placement\n    let currentGroup = root;\n\n    for (let c = 0; c < maxLevels; c++) {\n      const v = getV(r, c);\n\n      if (v === undefined) {\n        continue;\n      }\n\n      currentGroup = getOrCreateGroup(currentGroup, v);\n    }\n\n    for (let c = maxLevels; c <= range.e.c; c++) {\n      const v = getV(r, c);\n      const p = propertyHeadings[c - maxLevels];\n      currentGroup[p] = v;\n    }\n  }\n\n  const reduceIndex = root => Array.from(root.groups.values()).reduce(reducer, []);\n\n  const reducer = (groups, g) => {\n    const group = Object.keys(g).reduce((newGroup, prop) => {\n      if (prop !== \"groups\") {\n        newGroup[prop] = g[prop];\n      } else {\n        if (g.groups.size > 0) {\n          newGroup.groups = reduceIndex(g);\n        }\n      }\n\n      return newGroup;\n    }, {});\n    groups.push(group);\n    return groups;\n  };\n\n  dataObject.groups = reduceIndex(root);\n};\n_c = Worksheet2FoamTree;\n\nWorksheet2FoamTree.parse = worksheet => new Worksheet2FoamTree(worksheet);\n\nconst messages = {\n  \"E001\": \"The provided worksheet is empty, no data to import.\",\n  \"E002\": \"No hierarchy level headings found. The heading must follow the format 'Level N', where N is a number.\",\n  \"W001\": \"The provided worksheet has no data rows.\"\n};\n\nWorksheet2FoamTree.getMessage = entry => {\n  return messages[entry.code];\n};\n\nvar _c;\n\n$RefreshReg$(_c, \"Worksheet2FoamTree\");","map":{"version":3,"sources":["/home/charles/Desktop/foamtree-Site1/src/carrotsearch/spreadsheet.js"],"names":["XLSX","Worksheet2FoamTree","worksheet","log","dataObject","groups","propertyHeadings","getLog","getDataObject","getPropertyNames","get","r","c","utils","encode_cell","getV","e","v","rangeRaw","push","code","range","decode_range","LEVEL_HEADING_REGEX","maxLevels","test","i","root","Map","getOrCreateGroup","group","label","set","currentGroup","undefined","p","reduceIndex","Array","from","values","reduce","reducer","g","Object","keys","newGroup","prop","size","parse","messages","getMessage","entry"],"mappings":"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","sourcesContent":["import XLSX from \"xlsx\";\n\nexport const Worksheet2FoamTree = /** @constructor */ function (worksheet) {\n  const log = [];\n  const dataObject = { groups: [] };\n  const propertyHeadings = [];\n\n  this.getLog = () => log;\n\n  this.getDataObject = () => dataObject;\n  this.getPropertyNames = () => propertyHeadings;\n\n  const get = (r, c) => worksheet[XLSX.utils.encode_cell({ c: c, r: r })];\n  const getV = (r, c) => {\n    const e = get(r, c);\n    return e && e.v;\n  };\n\n  // Ensure that the worksheet is not empty\n  const rangeRaw = worksheet[\"!ref\"];\n  if (!rangeRaw) {\n    log.push({ code: \"E001\" });\n    return;\n  }\n\n  // Check if there is any data. The first row is a heading.\n  const range = XLSX.utils.decode_range(rangeRaw);\n  if (range.e.r <= 0) {\n    log.push({ code: \"W001\" });\n    dataObject.groups = [];\n    return;\n  }\n\n  // Look for level headings, we require a specific level heading format defined below.\n  const LEVEL_HEADING_REGEX = /level\\s+\\d+/i;\n  let maxLevels = 0;\n  while (maxLevels <= range.e.c && LEVEL_HEADING_REGEX.test(getV(0, maxLevels))) {\n    maxLevels++;\n  }\n\n  // No level headings found\n  if (maxLevels === 0) {\n    log.push({ code: \"E002\" });\n    return;\n  }\n\n  // Headings beyond the hierarchy definitions. These will be the custom group properties.\n  let i = maxLevels;\n  while (i <= range.e.c) {\n    propertyHeadings.push(getV(0, i));\n    i++;\n  }\n\n  // Build the data object.\n  const root = { groups: new Map() };\n  const getOrCreateGroup = (root, v) => {\n    let group = root.groups.get(v);\n    if (!group) {\n      group = { label: v, groups: new Map() };\n      root.groups.set(v, group);\n    }\n    return group;\n  };\n\n  for (let r = 1; r <= range.e.r; r++) {\n    // Hierarchy placement\n    let currentGroup = root;\n    for (let c = 0; c < maxLevels; c++) {\n      const v = getV(r, c);\n      if (v === undefined) {\n        continue;\n      }\n      currentGroup = getOrCreateGroup(currentGroup, v);\n    }\n\n    for (let c = maxLevels; c <= range.e.c; c++) {\n      const v = getV(r, c);\n      const p = propertyHeadings[c - maxLevels];\n      currentGroup[p] = v;\n    }\n  }\n\n  const reduceIndex = root => Array.from(root.groups.values()).reduce(reducer, []);\n  const reducer = (groups, g) => {\n    const group = Object.keys(g).reduce((newGroup, prop) => {\n      if (prop !== \"groups\") {\n        newGroup[prop] = g[prop];\n      } else {\n        if (g.groups.size > 0) {\n          newGroup.groups = reduceIndex(g);\n        }\n      }\n      return newGroup;\n    }, {});\n    groups.push(group);\n    return groups;\n  };\n  dataObject.groups = reduceIndex(root);\n};\n\nWorksheet2FoamTree.parse = worksheet => new Worksheet2FoamTree(worksheet);\n\nconst messages = {\n  \"E001\": \"The provided worksheet is empty, no data to import.\",\n  \"E002\": \"No hierarchy level headings found. The heading must follow the format 'Level N', where N is a number.\",\n  \"W001\": \"The provided worksheet has no data rows.\",\n};\n\nWorksheet2FoamTree.getMessage = entry => {\n  return messages[entry.code];\n};"]},"metadata":{},"sourceType":"module"}